<!DOCTYPE html>
<html lang="es">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Descubre-al-Impostor</title>
<link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;600;700&display=swap" rel="stylesheet">
<style>
:root{
  --bg:#0e1423; --card:#16203b; --accent:#7CE3B4; --muted:#a0aec0; --danger:#FF6B6B; --glass: rgba(255,255,255,0.05);
  --btn:#5B8CFF; --btn2:#7CE3B4; --impostor-bg:#1b1f36;
}

/* Base */
*{box-sizing:border-box;font-family:'Inter',system-ui,Arial,Helvetica,sans-serif;transition:all .18s ease}
body{margin:0;background:linear-gradient(180deg,#0b0f1f 0%, #0e1423 100%);color:#e6eef8;min-height:100vh}
.wrap{max-width:1150px;margin:20px auto;padding:16px;position:relative}
header{display:flex;justify-content:space-between;align-items:center;margin-bottom:16px}
h1{font-weight:700;font-size:22px;margin:0}
.muted{color:var(--muted);font-size:13px}

/* Badge para invitados - arriba derecha */
#guestBadge{
  position:fixed;
  top:18px;
  right:18px;
  background:linear-gradient(90deg,var(--btn2),var(--btn));
  color:#052044;
  padding:8px 12px;
  border-radius:999px;
  font-weight:700;
  font-size:13px;
  box-shadow:0 6px 18px rgba(0,0,0,0.4);
  display:none; /* se mostrará sólo para invitados después de entrar */
  z-index:1200;
}

/* Grid */
.grid{display:grid;grid-template-columns:320px 1fr 320px;gap:16px}
.card{background:var(--card);border-radius:16px;padding:16px;box-shadow:0 8px 24px rgba(0,0,0,0.4)}

/* Controls */
input,select,button,textarea{border-radius:30px;border:1px solid rgba(255,255,255,0.1);background:var(--glass);padding:10px 14px;color:inherit;font-size:14px}
button{cursor:pointer;font-weight:600;border:none}
.bigAction{background:var(--btn);color:#fff;padding:12px 18px;border-radius:30px;box-shadow:0 4px 12px rgba(91,140,255,0.5)}
.btn-ghost{background:transparent;border:1px solid rgba(255,255,255,0.15);color:#fff}
.btn-danger{background:var(--danger);color:#111}
.small{font-size:13px;padding:8px 14px}

/* Lists & cards */
.inviteBox{background:rgba(255,255,255,0.03);padding:12px;border-radius:16px}
.playersList{list-style:none;padding:0;margin:8px 0;max-height:340px;overflow:auto}
.playersList li{display:flex;justify-content:space-between;align-items:center;padding:10px 12px;border-radius:12px;background:rgba(255,255,255,0.02);margin-bottom:8px}
.playersList li.active{background:linear-gradient(90deg, rgba(124,227,180,0.1), rgba(91,140,255,0.1));box-shadow:0 0 0 3px rgba(124,227,180,0.2)}

.roleCard{display:flex;gap:12px;align-items:center;padding:16px;border-radius:16px;background:rgba(255,255,255,0.02);border:1px solid rgba(255,255,255,0.05)}
.roleBig{font-weight:700;font-size:22px;color:#fff}
.wordBox{margin-top:10px;padding:14px;border-radius:16px;background:rgba(255,255,255,0.03);font-weight:500}

.timer{font-size:26px;font-weight:700;color:var(--btn)}

.votingPanel{padding:14px;border-radius:16px;background:rgba(255,255,255,0.02)}
.voteRow{display:flex;align-items:center;gap:12px;padding:10px;border-radius:30px;margin-bottom:8px;background:rgba(255,255,255,0.02);cursor:pointer;transition:all .12s ease}
.voteRow:hover{background:rgba(124,227,180,0.08)}
.voteName{width:40%;font-weight:500}
.voteBar{flex:1;height:18px;background:rgba(255,255,255,0.05);border-radius:30px;overflow:hidden}
.voteFill{height:100%;background:linear-gradient(90deg,var(--btn),var(--btn2));width:0%;transition:width .5s ease}
.voteCount{width:40px;text-align:right;font-weight:600}
.voteSubmit{width:100%;padding:12px;border-radius:30px;background:var(--btn);color:#fff;font-weight:700}

.impostorChat{padding:12px;border-radius:16px;background:var(--impostor-bg);max-height:320px;overflow:auto}
.msg{padding:10px;border-radius:12px;margin-bottom:8px;background:rgba(255,255,255,0.02)}
.msg.self{background:linear-gradient(90deg, rgba(91,140,255,0.3), rgba(124,227,180,0.15))}

/* Admin-only helper class (JS toggles display based on isAdmin) */
.adminOnly{}

/* Minimal guest panel helpers (JS toggles class 'guest-minimal' on body) */
body.guest-minimal .left .controls,
body.guest-minimal .left input#numPlayers,
body.guest-minimal .left .controls .bigAction,
body.guest-minimal .left .controls .btn-ghost{
  display:none !important;
}

/* hide center admin controls for guests */
body.guest-minimal #categorySelect,
body.guest-minimal #startGameBtn,
body.guest-minimal #nextTurnBtn,
body.guest-minimal #enableVoteBtn,
body.guest-minimal #endGameBtn,
body.guest-minimal #resetGameBtn{
  display:none !important;
}

/* hide the invite box for guests after they joined */
body.guest-minimal #inviteBox{ display:none !important; }

body.admin-centralized .grid{grid-template-columns:1fr;}

/* small responsive */
@media(max-width:1100px){ .grid{grid-template-columns:1fr; padding-bottom:30px} .card{margin-bottom:12px} }

/* Sección de categoría: fondo negro */
.card > div > #categorySelect {
  background-color: #000; /* fondo negro */
  color: #fff;            /* texto blanco para visibilidad */
}
/* Colores personalizados para botones */
#nextTurnBtn {
  background-color: #7CE3B4; /* verde claro */
  color: #111; /* texto oscuro para contraste */
}

#enableVoteBtn {
  background-color: #FFA500; /* naranja */
  color: #111;
}

#resetGameBtn {
  background-color: #FFD700; /* amarillo */
  color: #111;
}

#startGameBtn {
  background-color: #2E8B57; /* verde más oscuro */
  color: #fff; /* texto blanco */
}

#joinRoomBtn {
  background-color: #8A2BE2; /* morado */
  color: #fff;
}

/* =========================
   OVERLAY (WELCOME SCREEN - OPTION 2)
   Fullscreen centered login before joining
   ========================= */
#welcomeOverlay{
  position:fixed; inset:0; z-index:1300;
  display:flex;align-items:center;justify-content:center;
  background:linear-gradient(180deg, rgba(2,6,23,0.9), rgba(6,12,32,0.9));
  color:#e6eef8;
}
#welcomeCard{
  width:520px; max-width:94%; background:linear-gradient(180deg,#0f1724, #111827);
  padding:28px;border-radius:12px;box-shadow:0 12px 40px rgba(0,0,0,0.6);
  text-align:center;
}
#welcomeCard h2{margin:0 0 12px 0;font-size:22px}
#welcomeCard p{color:var(--muted);margin-bottom:18px}
#welcomeCard input{width:100%;margin-bottom:12px;padding:12px;border-radius:10px;background:rgba(255,255,255,0.03);border:1px solid rgba(255,255,255,0.06)}
#welcomeCard button{width:100%;padding:12px;border-radius:10px;background:var(--btn);color:#052044;font-weight:700;}

/* hide entire game under overlay so guests can't interact before joining */
body.has-overlay .wrap{filter:blur(0.8px);pointer-events:none;user-select:none;}

/* small note under overlay */
#welcomeCard .smallMuted{font-size:13px;color:var(--muted);margin-top:10px}

/* end styles */
</style>
</head>
<body>
<!-- WELCOME OVERLAY (FULLSCREEN) -->
<div id="welcomeOverlay" style="display:none">
  <div id="welcomeCard" role="dialog" aria-modal="true">
    <h2>Unirse a la sala</h2>
    <p>Ingresa tu nombre y verifica el número de sala. Solo podrás ver el juego después de unirte.</p>
    <input id="overlayName" type="text" placeholder="Tu nombre (ej. Ana)" />
    <input id="overlayRoom" type="text" placeholder="Número de sala (ej. 1234)" />
    <button id="overlayJoinBtn">Unirse a la sala</button>
    <div class="smallMuted">Nota: el chat público está deshabilitado para jugadores. Solo impostores pueden chatear entre sí.</div>
  </div>
</div>

<div class="wrap">
  <header style="display:flex;align-items:center;justify-content:space-between">
    <h1>Impostor — Juego</h1>
    <div class="muted">Multijugador • Firebase</div>
  </header>

  <!-- Badge de sala para invitados (B-3): visible sólo a invitados dentro de la sala -->
  <div id="guestBadge" aria-hidden="true"></div>

  <div class="grid">
    <!-- LEFT: Lobby -->
    <div class="card left">
      <div style="margin-bottom:12px">
        <label class="muted">Tu nombre</label>
        <input id="playerName" placeholder="Ej: Ana">
      </div>

      <div style="margin-bottom:12px">
        <label class="muted">Número de sala (solo unirse)</label>
        <input id="joinRoomNumber" placeholder="Ej: 1234">
      </div>

      <div style="margin-bottom:12px">
        <label class="muted adminOnly">Jugadores requeridos (solo admin)</label>
        <input id="numPlayers" type="number" class="adminOnly" placeholder="Ej: 8">
      </div>

      <div class="controls" style="margin-bottom:12px">
        <button id="createRoomBtn" class="bigAction adminOnly">Crear Sala</button>
        <button id="joinRoomBtn" class="btn-ghost small">Unirse</button>
      </div>

      <div id="inviteBox" class="inviteBox" style="margin-bottom:12px">
        <div class="muted">Sala</div>
        <div id="roomInfo" style="font-weight:700;margin-top:6px">—</div>
        <div style="margin-top:8px" class="muted">Link de invitación:</div>
        <div id="inviteLink" style="margin-top:6px;word-break:break-all;color:var(--accent)">—</div>
      </div>

      <div style="margin-bottom:12px">
        <h3 style="margin-bottom:8px">Jugadores</h3>
        <ul id="playersList" class="playersList"></ul>
      </div>

      <div>
        <h3 style="margin-bottom:8px">Chat privado — Impostores</h3>
        <div id="impostorChatContainer" style="display:none">
          <div id="impostorChat" class="impostorChat"></div>
          <div style="display:flex;gap:8px;margin-top:8px">
            <input id="impostorMsg" placeholder="Mensaje a impostores..." style="flex:1;border-radius:20px;padding:10px">
            <button id="sendImpostor" class="small">Enviar</button>
          </div>
        </div>
      </div>
    </div>

    <!-- CENTER: Game -->
    <div class="card center-card">
      <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:12px">
        <div>
          <div class="muted">Sala</div>
          <div id="roomNumber" style="font-weight:700;font-size:18px">—</div>
        </div>
        <div style="text-align:right">
          <div class="muted">Turno actual</div>
          <div id="turnInfo" class="timer">—</div>
        </div>
      </div>

      <div class="roleCard">
        <div>
          <div class="muted">Tu rol</div>
          <div id="roleDisplay" class="roleBig">—</div>
          <div class="muted" style="margin-top:6px">Tu palabra / pista (privado)</div>
          <div id="wordDisplay" class="wordBox">—</div>
        </div>
      </div>

      <div id="centerControls" style="display:flex;gap:10px;margin-top:12px;flex-wrap:wrap;align-items:center">
        <select id="categorySelect" style="flex:1;border-radius:30px;padding:10px" class="adminOnly"></select>
        <button id="startGameBtn" class="small adminOnly" style="border-radius:30px;background:var(--btn);color:#052044">Iniciar</button>
      </div>

      <div id="centerAdminButtons" style="display:flex;gap:10px;margin-top:12px;flex-wrap:wrap">
        <button id="nextTurnBtn" class="btn-ghost small adminOnly" style="border-radius:30px">Siguiente Turno (Admin)</button>
        <button id="enableVoteBtn" class="btn-ghost small adminOnly" style="border-radius:30px">Forzar Votación</button>
        <button id="endGameBtn" class="btn-danger small adminOnly">Finalizar</button>
        <button id="resetGameBtn" class="btn-ghost small adminOnly" style="border-radius:30px">Reiniciar Partida</button>
      </div>

      <div style="margin-top:16px">
        <div class="muted">Cronómetro</div>
        <div id="timer" style="font-size:28px;font-weight:700;color:var(--btn);margin-top:6px">60s</div>
        <div id="roundInfo" class="muted" style="margin-top:8px" data-rounds="0">Rondas completadas: 0</div>
      </div>

      <div id="centerInviteLinkWrapper" style="margin-top:12px;display:block">
        <div class="muted">Link de invitación:</div>
        <div id="inviteLinkCenter" class="inviteBox" style="margin-top:8px;word-break:break-all;color:var(--accent)">—</div>
        <div style="margin-top:8px"><button id="copyInviteCenter" class="small">Copiar</button></div>
      </div>

      <div style="margin-top:12px">
        <h3 style="margin-bottom:8px">Lista de jugadores / Votación</h3>
        <ul id="playersCenterList" class="playersList"></ul>
        <div id="voteRows" style="margin-top:8px"></div>
        <div style="margin-top:8px"><button id="voteSubmitBtn" class="voteSubmit" disabled>Enviar mi voto</button></div>
      </div>

      <div id="centerImpostorChatWrapper" style="margin-top:12px">
        <h3 style="margin-bottom:8px">Chat privado — Impostores</h3>
        <div id="impostorChat_center" class="impostorChat" style="display:none"></div>
        <div style="display:flex;gap:8px;margin-top:8px">
          <input id="impostorMsg_center" placeholder="Mensaje a impostores..." style="flex:1;border-radius:20px;padding:10px">
          <button id="sendImpostor_center" class="small">Enviar</button>
        </div>
      </div>

    </div>

    <!-- RIGHT: Voting (moved into center when centralized) -->
    <div class="card right">
      <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:6px">
        <div><strong>Votación</strong></div>
        <div class="muted">Estado: <span id="votingStatus">Bloqueada</span></div>
      </div>

      <div class="votingPanel" id="votingPanel">
        <div id="voteRows_right"></div>
        <button id="voteSubmitBtn_right" class="voteSubmit" disabled>Enviar mi voto</button>
        <div class="muted" style="margin-top:8px">Haz click en una barra para seleccionar a quién votar. Las barras muestran conteo en tiempo real.</div>
        
        <!-- Overlay para indicar turno -->
<div id="turnOverlay" style="
    position: fixed;
    top:0;
    left:0;
    width:100%;
    height:100%;
    background-color: rgba(144, 238, 144, 0.6); /* verde claro semi-transparente */
    display: flex;
    justify-content: center;
    align-items: center;
    font-size: 5em;
    font-weight: bold;
    color: #006400; /* verde oscuro para el texto */
    z-index: 9999;
    pointer-events: none;
    display: none; /* oculto por defecto */
">
  TU TURNO
</div>

      </div>
    </div>
  </div>
</div>

<!-- Firebase (compat) -->
<script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-app-compat.js"></script>
<script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-database-compat.js"></script>

<script>
/* =========================
   Config Firebase — conserva la tuya
   ========================= */
const firebaseConfig = {
  apiKey: "AIzaSyAig1kHcEgjf-ncLUN2Vc2ZKBCC4sFHZWs",
  authDomain: "impostor-35ecf.firebaseapp.com",
  databaseURL: "https://impostor-35ecf-default-rtdb.firebaseio.com/",
  projectId: "impostor-35ecf",
  storageBucket: "impostor-35ecf.appspot.com",
  messagingSenderId: "351796401652",
  appId: "1:351796401652:web:fc1d656503fdd0fc08d5a1",
  measurementId: "G-5YQYFFB4T1"
};
firebase.initializeApp(firebaseConfig);
const db = firebase.database();

/* =========================
   Categorías (todas)
   ========================= */
const categories = {
  frutas: ["Manzana","Banana","Pera","Fresa","Naranja","Sandía","Mango","Kiwi","Uva","Cereza","Melón","Papaya","Piña","Durazno","Ciruela","Frambuesa","Arándano","Limón","Mandarina","Pomelo","Coco","Granada","Higo","Litchi","Guayaba"],
  animales: ["Perro","Gato","León","Tigre","Elefante","Jirafa","Cebra","Mono","Lobo","Oso","Rinoceronte","Hipopótamo","Conejo","Caballo","Vaca","Cerdo","Oveja","Pato","Gallina","Pez","Tortuga","Serpiente","Cocodrilo","Loro","Murciélago"],
  ciudades: ["París","Londres","Nueva York","Tokio","Madrid","Roma","Berlín","Lisboa","Barcelona","Sídney","Moscú","Beijing","Ámsterdam","Bangkok","Estambul","Dubai","Los Ángeles","Chicago","Buenos Aires","Seúl","Hong Kong","Toronto","Miami","San Petersburgo","Delhi","Praga"],
  colores: ["Rojo","Azul","Verde","Amarillo","Negro","Blanco","Rosa","Morado","Naranja","Gris","Marrón","Cian","Magenta","Violeta","Turquesa","Dorado","Plateado","Beige","Lila","Celeste","Oliva","Salmón","Borgoña","Índigo","Coral"],
  objetos: ["Mesa","Silla","Lámpara","Libro","Bolígrafo","Teléfono","Reloj","Computadora","Cuchara","Tenedor","Cuchillo","Ventana","Puerta","Zapato","Sombrero","Bolsa","Cartera","Guitarra","Televisor","Cámara","Espejo","Almohada","Cojín","Silla de ruedas","Paraguas"],
  peliculas: ["Titanic","Avatar","Inception","Gladiador","Matrix","El Padrino","Forrest Gump","Star Wars","Jurassic Park","Shrek","Frozen","El Rey León","Harry Potter","Joker","Interestelar","Spider-Man","Avengers","La La Land","Toy Story","Casablanca","El Señor de los Anillos","Up","Coco","Rapido y Furioso","Piratas del Caribe"],
  musica: ["Beatles","Queen","Michael Jackson","Madonna","Elton John","Beyoncé","Adele","Taylor Swift","Shakira","Coldplay","U2","AC/DC","Eminem","Drake","Ed Sheeran","Bruno Mars","Rihanna","Katy Perry","Justin Bieber","Lady Gaga","Linkin Park","Pink Floyd","Bob Marley","The Rolling Stones","David Bowie"],
  ciencia: ["Átomo","Molécula","Energía","Gravedad","Célula","Neurona","ADN","Gen","Fotosíntesis","Electrón","Protones","Quarks","Relatividad","Órbita","Planeta","Galaxia","Cometa","Virus","Bacteria","Fósil","Evolución","Hongo","Mineral","Oxígeno","Nitrógeno"],
  tecnologia: ["Computadora","Internet","Robot","Inteligencia Artificial","Smartphone","Tablet","Redes","Cámara","Impresora","Dron","Software","Hardware","Aplicación","WiFi","Bluetooth","Ciberseguridad","Procesador","Memoria","Disco Duro","Pantalla","Teclado","Ratón","Auriculares","Monitor","Servidor"],
  transporte: ["Coche","Bicicleta","Avión","Tren","Barco","Autobús","Moto","Camión","Submarino","Helicóptero","Tranvía","Metro","Monopatín","Patinete","Taxi","Furgoneta","Tractor","Caravana","Jet","Globo","Velero","Remo","Lancha","Ferry","Teleférico"],
  deportes: ["Fútbol","Baloncesto","Tenis","Béisbol","Golf","Natación","Boxeo","Rugby","Voleibol","Ciclismo","Atletismo","Esquí","Snowboard","Surf","Hockey","Skate","Karate","Taekwondo","Judo","Ping Pong","Bolos","Motocross","Escalada","Paracaidismo","Lucha libre"],
  animales_domesticos: ["Perro","Gato","Conejo","Pez","Hamster","Cobaya","Canario","Loro","Tortuga","Serpiente","Gallo","Pato","Caballo","Cabra","Oveja","Cerdo","Ratón","Hurón","Camaleón","Erizo","Gato Siamés","Pastor Alemán","Bulldog","Persa","Acuario"],
  comidas: ["Pizza","Hamburguesa","Sushi","Tacos","Paella","Ensalada","Pollo","Carne","Pasta","Arroz","Sopa","Pescado","Fruta","Verdura","Helado","Chocolate","Pan","Queso","Huevos","Galleta","Cereal","Crepa","Tortilla","Arepa","Empanada"],
  bebidas: ["Agua","Jugo","Café","Té","Cerveza","Vino","Refresco","Leche","Smoothie","Batido","Champán","Vodka","Whisky","Ron","Tequila","Sidra","Limonada","Mojito","Coca-Cola","Fanta","Sprite","Ginger Ale","Matcha","Mate","Chai"],
  estaciones: ["Primavera","Verano","Otoño","Invierno","Lluviosa","Seca","Fría","Caliente","Templada","Nevada","Húmeda","Vientos","Soleada","Nublada","Tormenta","Trueno","Relámpago","Aurora","Crepúsculo","Mañana","Tarde","Noche","Medianoche","Amanecer","Atardecer"],
  instrumentos: ["Guitarra","Piano","Batería","Violín","Flauta","Saxofón","Trompeta","Clarinete","Chelo","Arpa","Órgano","Acordeón","Tambor","Ukelele","Trombón","Corneta","Gong","Marimba","Xilófono","Castañuelas","Banjo","Timbal","Mandolina","Oboe","Fagot"],
  herramientas: ["Martillo","Destornillador","Taladro","Sierra","Alicate","Llave inglesa","Cúter","Cinta métrica","Nivel","Pala","Rastrillo","Tornillo","Clavo","Soplete","Taladro percutor","Tenazas","Sierra circular","Escuadra","Compás","Lima","Broca","Prensa","Sargentos","Flexómetro","Cepillo"],
  ropa: ["Camisa","Pantalón","Zapatos","Calcetines","Sombrero","Gorra","Chaqueta","Abrigo","Falda","Vestido","Cinturón","Bufanda","Guantes","Traje","Corbata","Botas","Sandalias","Chaleco","Pijama","Bata","Leggings","Shorts","Jeans","Camiseta","Sudadera"],
  animales_salvajes: ["León","Tigre","Elefante","Jirafa","Cebra","Hipopótamo","Rinoceronte","Oso","Lobo","Cocodrilo","Canguro","Jaguar","Pantera","Lince","Zorro","Búho","Águila","Lémur","Orangután","Gorila","Bisonte","Antílope","Hiena","Coyote","Serpiente"],
  emociones: ["Felicidad","Tristeza","Enojo","Miedo","Sorpresa","Amor","Odio","Alegría","Ansiedad","Confusión","Vergüenza","Celos","Frustración","Nostalgia","Entusiasmo","Orgullo","Satisfacción","Desesperación","Paz","Calma","Inquietud","Gratitud","Desdén","Curiosidad","Asombro"],
  muebles: ["Silla","Mesa","Cama","Armario","Escritorio","Estantería","Sofá","Lámpara","Banco","Taburete","Aparador","Cómoda","Vitrina","Perchero","Sillón","Mueble TV","Mesita","Zapatero","Mueble de cocina","Cama doble","Litera","Cuna","Butaca","Silla de oficina","Banco de trabajo"],
  transporte_publico: ["Autobús","Metro","Tren","Tranvía","Taxi","Uber","Mototaxi","Teleférico","Ferry","Bote","Tren ligero","Bus turístico","Trolebús","Monorraíl","Vagón","Coche compartido","Scooter","Motocicleta","Bicicleta pública","Camión urbano","Barco","Lancha","Furgoneta","Submarino","Helicóptero"],
  herramientas_cocina: ["Cuchillo","Tenedor","Cuchara","Cucharón","Espátula","Colador","Olla","Sartén","Batidora","Procesador","Rallador","Tijeras","Mortero","Tabla de cortar","Exprimidor","Cazo","Cucharita","Pinzas","Termómetro","Ramequin","Fuente","Recipiente","Moldes","Molde de pan","Cafetera"],
  tecnologia_antigua: ["Teléfono fijo","Máquina de escribir","Disquete","Televisor CRT","Radio antigua","Fax","Gramófono","Proyector","VHS","Walkman","Discman","Cámara analógica","Reloj de arena","Pizarra","Calculadora mecánica","Telégrafo","Linterna","Cinta VHS","Teléfono rotativo","Reproductor DVD","Discoteca","Cámara Polaroid","Videocámara","Scanner","Proyector de diapositivas"],
  politica: ["Joe Biden","Barack Obama","Angela Merkel","Nelson Mandela","Vladimir Putin","Winston Churchill","Margaret Thatcher","Mahatma Gandhi","Emmanuel Macron","Xi Jinping","Donald Trump","Fidel Castro","Jair Bolsonaro","Justin Trudeau","Jacinda Ardern","Abraham Lincoln","Franklin Roosevelt","Theodore Roosevelt","John F. Kennedy","Hillary Clinton","Kamala Harris","Benjamin Netanyahu","Catherine de Medici","Cleopatra","Napoleón"],
  futbol: ["Lionel Messi","Cristiano Ronaldo","Diego Maradona","Pelé","Zinedine Zidane","Neymar","Kylian Mbappé","Johan Cruyff","Ronaldinho","David Beckham","Sergio Ramos","Luka Modrić","Paolo Maldini","Thierry Henry","Andrés Iniesta","Luis Suárez","Robert Lewandowski","Eden Hazard","Harry Kane","Gianluigi Buffon","Wayne Rooney","Karim Benzema","Marcelo","Ronaldo Nazário","Iker Casillas"]
};

/* =========================
   Helpers y elementos DOM
   ========================= */
const $ = id => document.getElementById(id);
const playerNameInput = $('playerName');
const joinRoomInput = $('joinRoomNumber');
const numPlayersInput = $('numPlayers');
const createRoomBtn = $('createRoomBtn');
const joinRoomBtn = $('joinRoomBtn');
const roomInfo = $('roomInfo');
const inviteLink = $('inviteLink'); // left original
const inviteBox = $('inviteBox');
const playersListEl = $('playersList');
const playersCenterList = $('playersCenterList');
const roomNumberEl = $('roomNumber');
const roleDisplay = $('roleDisplay');
const wordDisplay = $('wordDisplay');
const categorySelect = $('categorySelect');
const startGameBtn = $('startGameBtn');
const nextTurnBtn = $('nextTurnBtn');
const enableVoteBtn = $('enableVoteBtn');
const endGameBtn = $('endGameBtn');
const resetGameBtn = $('resetGameBtn');
const timerEl = $('timer');
const roundInfoEl = $('roundInfo');
const impostorChatContainer = $('impostorChatContainer');
const impostorChat = $('impostorChat');
const impostorMsg = $('impostorMsg');
const sendImpostor = $('sendImpostor');
const voteRows = $('voteRows'); // center
const voteRows_right = $('voteRows_right'); // right original
const voteSubmitBtn = $('voteSubmitBtn'); // center
const voteSubmitBtn_right = $('voteSubmitBtn_right'); // right original
const votingStatus = $('votingStatus');
const guestBadge = $('guestBadge');

/* Center additional elements */
const inviteLinkCenter = $('inviteLinkCenter');
const copyInviteCenter = $('copyInviteCenter');
const impostorChat_center = $('impostorChat_center');
const impostorMsg_center = $('impostorMsg_center');
const sendImpostor_center = $('sendImpostor_center');

/* Overlay elements */
const welcomeOverlay = $('welcomeOverlay');
const overlayName = $('overlayName');
const overlayRoom = $('overlayRoom');
const overlayJoinBtn = $('overlayJoinBtn');

/* =========================
   Estado local
   ========================= */
let room = null;
let playerId = null;
let playerName = null;
let isAdmin = false;
let players = [];
let currentTurn = null;
let turnEndTimestamp = null;
let timerInterval = null;
let votingActive = false;
let myVote = null;
let turnsPlayedTotal = 0;
let votingStage = 0;

/* === Llenar categorías === */
for(const cat in categories){
  const opt = document.createElement('option');
  opt.value = cat;
  opt.textContent = cat.charAt(0).toUpperCase() + cat.slice(1);
  categorySelect.appendChild(opt);
}

/* === Util === */
function uid(){ return Date.now().toString(36) + Math.random().toString(36).slice(2,8); }
function now(){ return Date.now(); }

/* =========================
   UI: ocultar/mostrar según rol (admin vs invitado)
   ========================= */
function updateUIForRole(){
  const adminElems = document.querySelectorAll('.adminOnly');
  adminElems.forEach(el => el.style.display = isAdmin ? '' : 'none');

  if(!isAdmin){
    document.body.classList.add('guest-minimal');
    if(room) inviteBox.style.display = 'none';
    if(room){
      guestBadge.textContent = 'Sala ' + room;
      guestBadge.style.display = 'inline-block';
    }
  } else {
    document.body.classList.remove('guest-minimal');
    inviteBox.style.display = '';
    guestBadge.style.display = 'none';
  }
}

/* =========================
   Mostrar / ocultar overlay y activar panel
   ========================= */
function showWelcomeOverlay(show=true){
  if(show){
    welcomeOverlay.style.display = 'flex';
    document.body.classList.add('has-overlay');
  } else {
    welcomeOverlay.style.display = 'none';
    document.body.classList.remove('has-overlay');
  }
}

/* =========================
   Reorganizar UI al modo centralizado
   ========================= */
function applyCentralLayout(){
  // Mark body so CSS makes grid single-column
  document.body.classList.add('admin-centralized');

  // hide left and right cards visually (they remain in DOM but hidden)
  const leftCard = document.querySelector('.card.left');
  const rightCard = document.querySelector('.card.right');
  if(leftCard) leftCard.style.display = 'none';
  if(rightCard) rightCard.style.display = 'none';

  // populate center invite link from left inviteLink element if present
  if(inviteLink && inviteLink.textContent && inviteLink.textContent.trim() !== '—'){
    inviteLinkCenter.textContent = inviteLink.textContent;
  } else if(room){
    inviteLinkCenter.textContent = `${location.origin}${location.pathname}?room=${room}`;
  }

  // copy existing impostor chat into center (keep both in sync via DB listeners)
  // nothing to move structurally because center has its own chat container
  // ensure center chat visibility toggles according to role
  impostorChat_center.style.display = impostorChatContainer.style.display;

  // If the right voting panel had children (voteRows_right), we will mirror them into center voteRows.
  // We'll leave the data-binding intact by reusing voteRows (center) as main area.
  // Clear center voteRows so they will be rebuilt by buildVoteUI when votingActive true.
  voteRows.innerHTML = '';
}

/* =========================
   Crear / Unirse a sala (admin & left-panel join)
   ========================= */
createRoomBtn.addEventListener('click', ()=> {
  playerName = playerNameInput.value.trim() || "Anon";
  playerId = uid();
  isAdmin = true;
  const required = parseInt(numPlayersInput.value) || 4;
  const roomId = String(Math.floor(1000 + Math.random()*9000));
  room = roomId;

  db.ref('rooms/'+room+'/meta').set({
    requiredPlayers: required,
    status: 'lobby',
    category: null,
    currentTurnPlayer: null,
    turnEnd: null,
    voting: false,
    turnsPlayedTotal: 0,
    votingStage: 0,
    rounds: 0,
    winner: null,
    centralized: true
  });
  db.ref('rooms/'+room+'/players/'+playerId).set({
    name: playerName,
    admin: true,
    role: null,
    word: null,
    alive: true,
    votedFor: null
  });

  // Set visible room info
  roomInfo.textContent = room;
  inviteLink.textContent = `${location.origin}${location.pathname}?room=${room}`;
  roomNumberEl.textContent = room;

  // admin created the room -> hide overlay and show main UI
  showWelcomeOverlay(false);
  updateUIForRole();
  listenRoom(room);

  // Apply central layout locally and set DB flag already set above so others will follow
  applyCentralLayout();
});

joinRoomBtn.addEventListener('click', ()=> {
  playerName = playerNameInput.value.trim() || "Anon";
  playerId = uid();
  isAdmin = false;
  const joinId = joinRoomInput.value.trim();
  if(!joinId){ alert("Ingresa número de sala"); return; }
  room = joinId;

  db.ref('rooms/'+room+'/players/'+playerId).set({
    name: playerName,
    admin: false,
    role: null,
    word: null,
    alive: true,
    votedFor: null
  });

  roomInfo.textContent = room;
  inviteLink.textContent = `${location.origin}${location.pathname}?room=${room}`;
  roomNumberEl.textContent = room;

  showWelcomeOverlay(false);

  updateUIForRole();
  listenRoom(room);
});

overlayJoinBtn.addEventListener('click', async ()=>{
  const name = overlayName.value.trim() || overlayName.placeholder || 'Anon';
  const roomId = overlayRoom.value.trim();
  if(!roomId){ alert("Ingresa número de sala"); return; }

  playerName = name;
  playerId = uid();
  isAdmin = false;
  room = roomId;

  await db.ref('rooms/'+room+'/players/'+playerId).set({
    name: playerName,
    admin: false,
    role: null,
    word: null,
    alive: true,
    votedFor: null
  });

  roomInfo.textContent = room;
  inviteLink.textContent = `${location.origin}${location.pathname}?room=${room}`;
  roomNumberEl.textContent = room;

  showWelcomeOverlay(false);

  updateUIForRole();
  listenRoom(room);
});

/* =========================
   Inicializar desde URL (para invitados)
   ========================= */
(function initFromURL(){
  const params = new URLSearchParams(window.location.search);
  if(params.has('room')){
    overlayRoom.value = params.get('room');
    joinRoomInput.value = params.get('room');
    showWelcomeOverlay(true);
    document.body.classList.add('guest-minimal');
  } else {
    showWelcomeOverlay(false);
  }
})();


/* =========================
   Escuchar datos de la sala
   ========================= */
function listenRoom(roomId){
  if(!roomId) return;

  // Escuchar jugadores
  db.ref('rooms/'+roomId+'/players').on('value', snap=>{
    const val = snap.val() || {};
    players = Object.entries(val).map(([id,p])=>({id,...p}));
    renderPlayers();
    const me = players.find(p=>p.id===playerId);
    if(me) isAdmin = !!me.admin;
    updateUIForRole();
    renderRoleWord();
  });

  // Escuchar meta de la sala
  db.ref('rooms/'+roomId+'/meta').on('value', snap=>{
    const m = snap.val();
    if(!m) return;

    votingActive = !!m.voting;
    votingStatus.textContent = votingActive ? 'Activa' : 'Bloqueada';

    currentTurn = m.currentTurnPlayer || null;
    turnEndTimestamp = m.turnEnd || null;
    turnsPlayedTotal = m.turnsPlayedTotal || 0;
    votingStage = m.votingStage || 0;
    roundInfoEl.textContent = 'Rondas completadas: ' + (m.rounds || 0);
    if(m.category) categorySelect.value = m.category;

    // If centralized flag is present, apply central layout (everyone will get same visual)
    if(m.centralized){
      applyCentralLayout();
      // update center invite link content
      if(inviteLinkCenter) inviteLinkCenter.textContent = `${location.origin}${location.pathname}?room=${roomId}`;
      // hide original left/right elements
      document.querySelectorAll('.card.left, .card.right').forEach(el=>el.style.display='none');
      document.body.classList.add('admin-centralized');
    }

    if(currentTurn){
      const p = players.find(x=>x.id===currentTurn);
      $('turnInfo').textContent = p ? p.name : '—';
      startLocalTimer();
    } else {
      $('turnInfo').textContent = '—';
      timerEl.textContent = '—';
      clearInterval(timerInterval);
    }

    if(votingActive){
      buildVoteUI();
    } else {
      voteRows.innerHTML = '';
      voteSubmitBtn.disabled = true;
      myVote = null;
    }

    renderRoleWord();
  });

  // Escuchar chat de impostores
  db.ref('rooms/'+roomId+'/impostorChat').on('value', snap=>{
    const data = snap.val() || {};
    // populate both left and center chat areas so either can show messages
    if(impostorChat) impostorChat.innerHTML = '';
    if(impostorChat_center) impostorChat_center.innerHTML = '';
    Object.values(data).forEach(msg=>{
      const d = document.createElement('div');
      d.className = 'msg' + (msg.fromId===playerId ? ' self' : '');
      d.textContent = `${msg.fromName}: ${msg.text}`;
      if(impostorChat) impostorChat.appendChild(d);
      if(impostorChat_center) impostorChat_center.appendChild(d.cloneNode(true));
    });
    if(impostorChat) impostorChat.scrollTop = impostorChat.scrollHeight;
    if(impostorChat_center) impostorChat_center.scrollTop = impostorChat_center.scrollHeight;
  });

  // Escuchar votos
  db.ref('rooms/'+roomId+'/votes').on('value', snap=>{
    const votes = snap.val() || {};
    updateVoteBars(votes);

    const aliveCount = players.filter(p => p.alive).length;
    if(Object.keys(votes).length === aliveCount && votingActive){
      concludeVoting(votes);
    }
  });
}

/* =========================
   Construir UI de votación
   ========================= */
function buildVoteUI(){
  voteRows.innerHTML = '';
  const alivePlayers = players.filter(p=>p.alive);
  alivePlayers.forEach(p=>{
    const row = document.createElement('div');
    row.className = 'voteRow';
    row.dataset.target = p.id;
    row.innerHTML = `<div class="voteName">${p.name}</div><div class="voteBar"><div class="voteFill"></div></div><div class="voteCount">0</div>`;

    // Click para seleccionar voto
    row.addEventListener('click', () => {
      if(!votingActive) return; // usar estado local
      if(p.id === playerId) return; // no votar por uno mismo
      myVote = p.id;
      Array.from(voteRows.children).forEach(r => r.classList.remove('active'));
      row.classList.add('active');
      voteSubmitBtn.disabled = false;
    });

    voteRows.appendChild(row);
  });

  const me = players.find(p=>p.id===playerId);
  voteSubmitBtn.disabled = !(me && me.alive);
  myVote = null;
}


/* =========================
   Render UI helpers
   ========================= */
function renderPlayers(){
  playersListEl.innerHTML = '';
  playersCenterList.innerHTML = '';
  players.forEach(p=>{
    const li = document.createElement('li');
    li.textContent = p.name + (p.admin ? ' (admin)' : '') + (p.alive ? '' : ' ✖');
    if(p.id === currentTurn) li.classList.add('active');
    playersListEl.appendChild(li);
    playersCenterList.appendChild(li.cloneNode(true));
  });
}

// Función para mostrar/ocultar chat de impostores según rol
function toggleImpostorChat(role){
  const isImpostor = role === 'Impostor';
  const centerActive = document.body.classList.contains('admin-centralized');

  if(centerActive){
    impostorChat_center.style.display = isImpostor ? 'block' : 'none';
  } else {
    impostorChatContainer.style.display = isImpostor ? 'block' : 'none';
  }
}

function renderRoleWord(){
  const me = players.find(p => p.id === playerId);

  if(me){
    roleDisplay.textContent = me.role || '—';

    if(me.role === 'Impostor'){
      db.ref('rooms/'+room+'/meta/category').once('value').then(s => {
        const cat = s.val() || '—';
        wordDisplay.textContent = 'Categoría: ' + cat;
      });
    } else {
      wordDisplay.textContent = me.word || '—';
    }

    // Llamar a la función que controla la visibilidad del chat
    toggleImpostorChat(me.role);

  } else {
    roleDisplay.textContent = '—';
    wordDisplay.textContent = '—';
    toggleImpostorChat(null); // ocultar chat si no hay jugador
  }
}


/* =========================
   Start game: roles & words
   ========================= */
startGameBtn.addEventListener('click', async ()=> {
  if(!room) return alert('No estás en ninguna sala');
  if(!isAdmin) return alert('Sólo admin puede iniciar');

  const metaSnap = await db.ref('rooms/'+room+'/meta').once('value');
  const meta = metaSnap.val() || {};
  const required = meta.requiredPlayers || 4;

  if(players.length < required) return alert(`Se necesitan ${required} jugadores para iniciar`);

  // Elegir categoría y palabras
  const category = categorySelect.value || Object.keys(categories)[0];
  const wordsPool = (categories[category] || []).slice();

  // Orden aleatorio de jugadores
  const shuffled = players.slice().sort(()=>Math.random()-0.5);

  // Definir impostores
  const impostorCount = Math.max(1, Math.floor(shuffled.length / 4));
  const impostors = shuffled.slice(0, impostorCount).map(p=>p.id);

  // Asegurar que el primer jugador no sea impostor
  let firstNonImpostorIndex = shuffled.findIndex(p => !impostors.includes(p.id));
  if(firstNonImpostorIndex > 0){
      [shuffled[0], shuffled[firstNonImpostorIndex]] = [shuffled[firstNonImpostorIndex], shuffled[0]];
  }

  // Elegir palabra secreta
  const secretWord = wordsPool.splice(Math.floor(Math.random()*wordsPool.length),1)[0] || '—';

  const updates = {};
  shuffled.forEach((p)=>{
    if(impostors.includes(p.id)){
      updates['rooms/'+room+'/players/'+p.id+'/role'] = 'Impostor';
      updates['rooms/'+room+'/players/'+p.id+'/word'] = null;
    } else {
      updates['rooms/'+room+'/players/'+p.id+'/role'] = 'Jugador';
      updates['rooms/'+room+'/players/'+p.id+'/word'] = secretWord;
    }
    updates['rooms/'+room+'/players/'+p.id+'/alive'] = true;
    updates['rooms/'+room+'/players/'+p.id+'/votedFor'] = null;
  });

  // Actualizar meta de la sala
  updates['rooms/'+room+'/meta/category'] = category;
  updates['rooms/'+room+'/meta/status'] = 'playing';
  updates['rooms/'+room+'/meta/currentTurnPlayer'] = shuffled[0].id;
  updates['rooms/'+room+'/meta/turnEnd'] = now() + 30000; // cronómetro 30s
  updates['rooms/'+room+'/meta/voting'] = false;
  updates['rooms/'+room+'/meta/turnsPlayedTotal'] = 0;
  updates['rooms/'+room+'/meta/votingStage'] = 0;
  updates['rooms/'+room+'/meta/rounds'] = 0;
  updates['rooms/'+room+'/votes'] = null;
  updates['rooms/'+room+'/impostorChat'] = null;
  updates['rooms/'+room+'/meta/winner'] = null;

  await db.ref().update(updates);
});


/* =========================
   Timer and turns
   ========================= */
function startLocalTimer(){
  clearInterval(timerInterval);
  if(!turnEndTimestamp) { timerEl.textContent = '—'; return; }
  function tick(){
    const left = Math.max(0, Math.floor((turnEndTimestamp - now())/1000));
    timerEl.textContent = left + 's';
    if(left <= 0){
      clearInterval(timerInterval);
      if(isAdmin) adminNextTurn();
    }
  }

  if(typeof turnEndTimestamp !== 'number'){
    db.ref('rooms/'+room+'/meta/turnEnd').once('value').then(s=>{ turnEndTimestamp = s.val() || null; });
  }
  tick();
  timerInterval = setInterval(()=>{ 
    db.ref('rooms/'+room+'/meta/turnEnd').once('value').then(s=>{ turnEndTimestamp = s.val() || null; tick(); });
  }, 1000);
}

nextTurnBtn.addEventListener('click', ()=>{ if(!isAdmin) return alert('Solo admin puede cambiar turno'); adminNextTurn(); });

/* =========================
   Turnos, contador y votación
   ========================= */
function adminNextTurn() {
  if (!room) return;
  const metaRef = db.ref('rooms/' + room + '/meta');
  metaRef.once('value').then(snap => {
    const m = snap.val() || {};
    const cur = m.currentTurnPlayer || null;
    const alive = players.filter(p => p.alive).map(p => p.id);
    if (alive.length === 0) return;

    let idx = alive.indexOf(cur);
    if (idx < 0) idx = 0;
    const nextIdx = (idx + 1) % alive.length;
    const nextId = alive[nextIdx];

    let turnsPlayed = (m.turnsPlayedTotal || 0) + 1;
    let voting = !!m.voting;
    let votingStageLocal = m.votingStage || 0;
    let rounds = m.rounds || 0;

    // Increment rounds al completar un ciclo completo de turnos
    if (nextIdx === 0) rounds++;

    // Lógica de activación de votación según la etapa
    if (votingStageLocal === 0 && rounds >= 2) {
      voting = true;
      votingStageLocal = 1;
    }
    if (votingStageLocal === 2 && rounds >= 3) {
      voting = true;
      votingStageLocal = 3;
    }

    const updates = {
      currentTurnPlayer: nextId,
      // Si se activa votación, pausamos el timer (turnEnd = null)
      turnEnd: voting ? null : now() + 30000,
      turnsPlayedTotal: turnsPlayed,
      voting: voting,
      votingStage: votingStageLocal,
      rounds: rounds
    };
    
    // Escuchar cambios en el jugador que tiene el turno
db.ref('rooms/'+room+'/meta/currentTurnPlayer').on('value', snap => {
    const currentTurn = snap.val();
    const turnOverlay = document.getElementById('turnOverlay');
    if(currentTurn === playerId){ 
        // Si es mi turno, mostrar overlay
        turnOverlay.style.display = 'flex';
    } else {
        // Si no es mi turno, ocultar overlay
        turnOverlay.style.display = 'none';
    }
});


    metaRef.update(updates);
  });
}


function startLocalTimer() {
  clearInterval(timerInterval);

  function tick() {
    if (votingActive) {
      timerEl.textContent = 'Votación…';
      return;
    }

    if (!turnEndTimestamp) {
      timerEl.textContent = '—';
      return;
    }

    const left = Math.max(0, Math.floor((turnEndTimestamp - Date.now()) / 1000));
    timerEl.textContent = left + 's';

    if (left <= 0) {
      clearInterval(timerInterval);
      if (isAdmin) adminNextTurn();
    }
  }

  // Obtener el timestamp actual de Firebase si no lo tenemos
  if (!turnEndTimestamp && room) {
    db.ref('rooms/' + room + '/meta/turnEnd').once('value').then(snap => {
      turnEndTimestamp = snap.val() || (Date.now() + 30000);
      tick();
    });
  } else {
    tick();
  }

  timerInterval = setInterval(tick, 1000);
}

/* =========================
   Conclusión de votación
   ========================= */
async function concludeVoting(votesObj) {
  if (!room) return;
  const metaSnap = await db.ref('rooms/' + room + '/meta').once('value');
  const meta = metaSnap.val() || {};
  if (!meta.voting) return;

  const counts = {};
  Object.values(votesObj || {}).forEach(v => counts[v] = (counts[v] || 0) + 1);

  let max = 0, candidate = null;
  for (const id in counts) {
    if (counts[id] > max) { max = counts[id]; candidate = id; }
    else if (counts[id] === max) candidate = null;
  }

  const updatesMeta = {};

  if (candidate) {
    const candPlayer = players.find(p => p.id === candidate);
    if (candPlayer && candPlayer.role === 'Impostor') {
      updatesMeta.status = 'ended';
      updatesMeta.winner = 'players';
      updatesMeta.voting = false;
      updatesMeta.votingStage = 0;
      updatesMeta.turnsPlayedTotal = 0;
      await db.ref('rooms/' + room + '/meta').update(updatesMeta);
      await db.ref('rooms/' + room + '/votes').set(null);
      votingActive = false;
      turnEndTimestamp = null; // Pausar cronómetro
      votingStatus.textContent = 'Bloqueada';
      voteRows.innerHTML = '';
      alert("¡El impostor ha sido descubierto! Ganaron los jugadores.");
      return;
    } else {
      if (meta.votingStage === 1) {
        updatesMeta.voting = false;
        updatesMeta.votingStage = 2;
        updatesMeta.turnsPlayedTotal = 0;
        const firstAlive = players.find(p => p.alive);
        updatesMeta.currentTurnPlayer = firstAlive ? firstAlive.id : null;
        updatesMeta.turnEnd = now() + 30000; // Reinicia 30s
      } else if (meta.votingStage === 3) {
        updatesMeta.status = 'ended';
        updatesMeta.winner = 'impostor';
        updatesMeta.voting = false;
        updatesMeta.votingStage = 0;
        updatesMeta.turnsPlayedTotal = 0;
        await db.ref('rooms/' + room + '/meta').update(updatesMeta);
        await db.ref('rooms/' + room + '/votes').set(null);
        votingActive = false;
        turnEndTimestamp = null;
        votingStatus.textContent = 'Bloqueada';
        voteRows.innerHTML = '';
        alert("No descubrieron al impostor. ¡El impostor gana!");
        return;
      }
    }
  } else {
    if (meta.votingStage === 1) {
      updatesMeta.voting = false;
      updatesMeta.votingStage = 2;
      updatesMeta.turnsPlayedTotal = 0;
      const firstAlive = players.find(p => p.alive);
      updatesMeta.currentTurnPlayer = firstAlive ? firstAlive.id : null;
      updatesMeta.turnEnd = now() + 30000; // Reinicia 30s
    } else if (meta.votingStage === 3) {
      updatesMeta.status = 'ended';
      updatesMeta.winner = 'impostor';
      updatesMeta.voting = false;
      updatesMeta.votingStage = 0;
      updatesMeta.turnsPlayedTotal = 0;
      await db.ref('rooms/' + room + '/meta').update(updatesMeta);
      await db.ref('rooms/' + room + '/votes').set(null);
      votingActive = false;
      turnEndTimestamp = null;
      votingStatus.textContent = 'Bloqueada';
      voteRows.innerHTML = '';
      alert("No descubrieron al impostor. ¡El impostor gana!");
      return;
    }
  }

  await db.ref('rooms/' + room + '/meta').update(updatesMeta);
  await db.ref('rooms/' + room + '/votes').set(null);
  votingActive = false;
  votingStatus.textContent = 'Bloqueada';
  voteRows.innerHTML = '';

  // Reiniciar cronómetro local si hubo turnEnd
  if (updatesMeta.turnEnd) {
    turnEndTimestamp = updatesMeta.turnEnd;
    startLocalTimer(); // <--- Esto reinicia el cronómetro
  }
}

/* =========================
   Chat impostores
   ========================= */
sendImpostor.addEventListener('click', () => {
  const me = players.find(p => p.id === playerId);
  if (!me || me.role !== 'Impostor') return; // SOLO IMPOSITOR
  const text = impostorMsg.value.trim();
  if (!text || !room) return;
  db.ref('rooms/' + room + '/impostorChat').push({
    fromId: playerId,
    fromName: playerName,
    text: text,
    ts: now()
  });
  impostorMsg.value = '';
});

sendImpostor_center.addEventListener('click', () => {
  const me = players.find(p => p.id === playerId);
  if (!me || me.role !== 'Impostor') return; // SOLO IMPOSITOR
  const text = impostorMsg_center.value.trim();
  if (!text || !room) return;
  db.ref('rooms/' + room + '/impostorChat').push({
    fromId: playerId,
    fromName: playerName,
    text: text,
    ts: now()
  });
  impostorMsg_center.value = '';
});

/* =========================
   Voting helpers
   ========================= */
enableVoteBtn.addEventListener('click', ()=>{
  if(!isAdmin) return alert('Solo admin puede forzar votación');
  db.ref('rooms/'+room+'/meta').update({ voting: true });
  db.ref('rooms/'+room+'/votes').set(null);
  votingActive = true;
  votingStatus.textContent = 'Activa';
  buildVoteUI();
});

function buildVoteUI(){
  voteRows.innerHTML = '';
  const alivePlayers = players.filter(p=>p.alive);
  alivePlayers.forEach(p=>{
    const row = document.createElement('div');
    row.className = 'voteRow';
    row.dataset.target = p.id;
    row.innerHTML = `<div class="voteName">${p.name}</div><div class="voteBar"><div class="voteFill"></div></div><div class="voteCount">0</div>`;
    row.addEventListener('click', ()=>{
      db.ref('rooms/'+room+'/meta/voting').once('value').then(s=>{
        const vActive = !!s.val();
        if(!vActive) return;
        if(p.id === playerId) return;
        myVote = p.id;
        Array.from(voteRows.children).forEach(r=>r.classList.remove('active'));
        row.classList.add('active');
        voteSubmitBtn.disabled = false;
      });
    });
    voteRows.appendChild(row);
  });

  const me = players.find(p=>p.id === playerId);
  voteSubmitBtn.disabled = !(me && me.alive);
  myVote = null;
}

voteSubmitBtn.addEventListener('click', ()=>{
  if(!myVote || !room) return;
  db.ref('rooms/'+room+'/votes/'+playerId).set(myVote);
  voteSubmitBtn.disabled = true;
});

function updateVoteBars(votesObj){
  const counts = {};
  Object.values(votesObj || {}).forEach(v=> counts[v] = (counts[v]||0)+1);
  Array.from(voteRows.children).forEach(row=>{
    const id = row.dataset.target;
    const count = counts[id] || 0;
    const aliveCount = Math.max(1, players.filter(p=>p.alive).length);
    const pct = Math.round((count / aliveCount) * 100);
    const fill = row.querySelector('.voteFill');
    const num = row.querySelector('.voteCount');
    if(fill) fill.style.width = pct + '%';
    if(num) num.textContent = count;
  });
}

/* =========================
   concludeVoting
   ========================= */
async function concludeVoting(votesObj){
  if(!room) return;
  const metaSnap = await db.ref('rooms/'+room+'/meta').once('value');
  const meta = metaSnap.val() || {};
  if(!meta.voting) return;

  const counts = {};
  Object.values(votesObj || {}).forEach(v=> counts[v] = (counts[v]||0)+1);
  let max = 0, candidate = null;
  for(const id in counts){
    if(counts[id] > max){ max = counts[id]; candidate = id; }
    else if(counts[id] === max) candidate = null;
  }

  const updatesMeta = {};
  if(candidate){
    const candPlayer = players.find(p => p.id === candidate);
    if(candPlayer && candPlayer.role === 'Impostor'){
      updatesMeta.status = 'ended';
      updatesMeta.winner = 'players';
      updatesMeta.voting = false;
      updatesMeta.votingStage = 0;
      updatesMeta.turnsPlayedTotal = 0;
      await db.ref('rooms/'+room+'/meta').update(updatesMeta);
      await db.ref('rooms/'+room+'/votes').set(null);
      votingActive = false;
      votingStatus.textContent = 'Bloqueada';
      voteRows.innerHTML = '';
      alert("¡El impostor ha sido descubierto! Ganaron los jugadores. Admin puede iniciar otra partida en la misma sala.");
      return;
    } else {
      if(meta.votingStage === 1){
        updatesMeta.voting = false;
        updatesMeta.votingStage = 2;
        updatesMeta.turnsPlayedTotal = 0;
        const firstAlive = players.find(p=>p.alive);
        updatesMeta.currentTurnPlayer = firstAlive ? firstAlive.id : null;
        updatesMeta.turnEnd = now() + 30000;
      } else if(meta.votingStage === 3){
        updatesMeta.status = 'ended';
        updatesMeta.winner = 'impostor';
        updatesMeta.voting = false;
        updatesMeta.votingStage = 0;
        updatesMeta.turnsPlayedTotal = 0;
        await db.ref('rooms/'+room+'/meta').update(updatesMeta);
        await db.ref('rooms/'+room+'/votes').set(null);
        votingActive = false;
        votingStatus.textContent = 'Bloqueada';
        voteRows.innerHTML = '';
        alert("No descubrieron al impostor. ¡El impostor gana!");
        return;
      } else {
        updatesMeta.voting = false;
        updatesMeta.votingStage = 0;
        updatesMeta.turnsPlayedTotal = 0;
      }
    }
  } else {
    if(meta.votingStage === 1){
      updatesMeta.voting = false;
      updatesMeta.votingStage = 2;
      updatesMeta.turnsPlayedTotal = 0;
      const firstAlive = players.find(p=>p.alive);
      updatesMeta.currentTurnPlayer = firstAlive ? firstAlive.id : null;
      updatesMeta.turnEnd = now() + 30000;
    } else if(meta.votingStage === 3){
      updatesMeta.status = 'ended';
      updatesMeta.winner = 'impostor';
      updatesMeta.voting = false;
      updatesMeta.votingStage = 0;
      await db.ref('rooms/'+room+'/meta').update(updatesMeta);
      await db.ref('rooms/'+room+'/votes').set(null);
      votingActive = false;
      votingStatus.textContent = 'Bloqueada';
      voteRows.innerHTML = '';
      alert("No descubrieron al impostor. ¡El impostor gana!");
      return;
    } else {
      updatesMeta.voting = false;
      updatesMeta.votingStage = 0;
      updatesMeta.turnsPlayedTotal = 0;
    }
  }

  await db.ref('rooms/'+room+'/meta').update(updatesMeta);
  await db.ref('rooms/'+room+'/votes').set(null);
  votingActive = false;
  votingStatus.textContent = 'Bloqueada';
  voteRows.innerHTML = '';
}

/* =========================
   Keep connection alive (optional)
   ========================= */
db.ref().on('value', ()=>{});

/* =========================
   Fallback periodic UI refresh
   ========================= */
setInterval(()=>{
  const me = players.find(p=>p.id===playerId);
  if(me){
    roleDisplay.textContent = me.role || '—';
    wordDisplay.textContent = (me.role==='Impostor') ? ('Categoría: ' + (categorySelect.value || '—')) : (me.word || '—');
    const centerActive = document.body.classList.contains('admin-centralized');
    if(centerActive){
      impostorChat_center.style.display = (me.role==='Impostor') ? 'block' : 'none';
    } else {
      impostorChatContainer.style.display = (me.role==='Impostor') ? 'block' : 'none';
    }
  }
  db.ref('rooms/'+room+'/meta/rounds').once('value').then(s=>{
    const r = s.val() || 0;
    roundInfoEl.textContent = 'Rondas completadas: ' + r;
  });
}, 1000);

/* =========================
   End / Reset
   ========================= */
endGameBtn.addEventListener('click', ()=>{
  if(!isAdmin) return alert('Solo admin puede finalizar');
  if(!room) return;
  db.ref('rooms/'+room).remove();
  location.reload();
});

/* Reiniciar: roles y orden aleatorio sin eliminar sala */
resetGameBtn.addEventListener('click', async () => {
  if(!isAdmin) return alert("Solo el administrador puede reiniciar la partida.");
  if(!room) return;
  const playersRef = db.ref('rooms/' + room + '/players');
  const playersSnap = await playersRef.once('value');
  const playersObj = playersSnap.val() || {};
  const ids = Object.keys(playersObj);
  if(ids.length < 2) return alert("Se necesitan al menos 2 jugadores para reiniciar la partida.");

  const shuffledIds = ids.sort(() => Math.random() - 0.5);
  const impostorCount = Math.max(1, Math.floor(shuffledIds.length / 4));
  const impostorIds = shuffledIds.slice(0, impostorCount);

  const updatedPlayers = {};
  shuffledIds.forEach((id, index) => {
    const original = playersObj[id];
    updatedPlayers[id] = {
      ...original,
      order: index + 1,
      role: (impostorIds.includes(id) ? "Impostor" : "Jugador"),
      word: null,
      alive: true,
      votedFor: null
    };
  });

  const resetMeta = {
    status: "waiting",
    winner: null,
    voting: false,
    votingStage: 0,
    turnsPlayedTotal: 0,
    currentTurnPlayer: null,
    turnEnd: 0,
    rounds: 0,
    category: null
  };

  await db.ref('rooms/' + room + '/votes').set(null);
  await db.ref('rooms/' + room + '/impostorChat').set(null);
  await playersRef.set(updatedPlayers);
  await db.ref('rooms/' + room + '/meta').update(resetMeta);

  alert("Partida reiniciada. Roles y orden re-asignados. El admin debe elegir categoría y presionar INICIAR.");
});

/* =========================
   Quick join via URL helper (also used to prefill overlay)
   ========================= */
window.addEventListener('load', ()=>{
  const params = new URLSearchParams(window.location.search);
  if(params.has('room')){
    joinRoomInput.value = params.get('room');
  }
});
</script>
</body>
</html>
```
